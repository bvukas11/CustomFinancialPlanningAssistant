// PART 2 OF FINANCIALSERVICE - ADDITIONAL METHODS
// This file contains the remaining implementation methods
// Copy these into FinancialService.cs before the closing brace

#region Trend Analysis Methods

public async Task<TrendAnalysisDto> AnalyzeTrendsAsync(List<int> documentIds)
{
    var periods = new List<string>();
    foreach (var docId in documentIds)
    {
        var doc = await _documentRepo.GetWithDataAsync(docId);
        if (doc?.FinancialDataRecords.Any() == true)
        {
            var period = doc.FinancialDataRecords.First().Period;
            if (!periods.Contains(period))
                periods.Add(period);
        }
    }

    return await AnalyzeTrendsByPeriodAsync(periods);
}

public async Task<TrendAnalysisDto> AnalyzeTrendsByPeriodAsync(List<string> periods)
{
    try
    {
        _logger.LogInformation("Analyzing trends for {Count} periods", periods.Count);

        var allData = new List<FinancialData>();
        foreach (var period in periods.OrderBy(p => p))
        {
            var periodData = await _dataRepo.GetByPeriodAsync(period);
            allData.AddRange(periodData);
        }

        if (!allData.Any())
        {
            throw new InvalidOperationException("No data found for specified periods");
        }

        var periodTotals = allData
            .GroupBy(d => d.Period)
            .OrderBy(g => g.Key)
            .Select(g => new TrendDataPoint
            {
                Period = g.Key,
                Value = g.Sum(d => d.Amount)
            })
            .ToList();

        for (int i = 1; i < periodTotals.Count; i++)
        {
            var previous = periodTotals[i - 1].Value;
            var current = periodTotals[i].Value;

            if (previous != 0)
            {
                periodTotals[i].PercentageChange = ((current - previous) / previous) * 100;
            }
        }

        var trendDirection = DetermineTrendDirection(periodTotals);
        var growthRates = periodTotals
            .Where(p => p.PercentageChange.HasValue)
            .Select(p => p.PercentageChange.Value)
            .ToList();

        var avgGrowthRate = growthRates.Any() ? growthRates.Average() : 0;

        var result = new TrendAnalysisDto
        {
            Category = "Overall",
            DataPoints = periodTotals,
            TrendDirection = trendDirection,
            AverageGrowthRate = avgGrowthRate,
            StartPeriod = periods.First(),
            EndPeriod = periods.Last(),
            TotalChange = periodTotals.Last().Value - periodTotals.First().Value,
            PercentageChange = periodTotals.First().Value != 0
                ? ((periodTotals.Last().Value - periodTotals.First().Value) / periodTotals.First().Value) * 100
                : 0
        };

        result.Insights = GenerateTrendInsights(result);

        return result;
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Error analyzing trends");
        throw;
    }
}

public async Task<List<TrendDataPoint>> GetTrendDataAsync(string category, List<string> periods)
{
    var dataPoints = new List<TrendDataPoint>();

    foreach (var period in periods.OrderBy(p => p))
    {
        var periodData = await _dataRepo.GetByPeriodAsync(period);
        var categoryData = periodData.Where(d => d.Category.Equals(category, StringComparison.OrdinalIgnoreCase));

        var total = categoryData.Sum(d => d.Amount);

        dataPoints.Add(new TrendDataPoint
        {
            Period = period,
            Value = total
        });
    }

    for (int i = 1; i < dataPoints.Count; i++)
    {
        var previous = dataPoints[i - 1].Value;
        var current = dataPoints[i].Value;

        if (previous != 0)
        {
            dataPoints[i].PercentageChange = ((current - previous) / previous) * 100;
        }
    }

    return dataPoints;
}

public async Task<decimal> CalculateGrowthRateAsync(string category, string startPeriod, string endPeriod)
{
    var startData = await _dataRepo.GetByPeriodAsync(startPeriod);
    var endData = await _dataRepo.GetByPeriodAsync(endPeriod);

    var startValue = startData
        .Where(d => d.Category.Equals(category, StringComparison.OrdinalIgnoreCase))
        .Sum(d => d.Amount);

    var endValue = endData
        .Where(d => d.Category.Equals(category, StringComparison.OrdinalIgnoreCase))
        .Sum(d => d.Amount);

    if (startValue == 0)
        return 0;

    return ((endValue - startValue) / startValue) * 100;
}

private string DetermineTrendDirection(List<TrendDataPoint> dataPoints)
{
    if (dataPoints.Count < 2)
        return "Insufficient Data";

    var changes = dataPoints
        .Where(p => p.PercentageChange.HasValue)
        .Select(p => p.PercentageChange.Value)
        .ToList();

    if (!changes.Any())
        return "Stable";

    var avgChange = changes.Average();

    if (avgChange > 5)
        return "Increasing";
    else if (avgChange < -5)
        return "Decreasing";
    else
        return "Stable";
}

private List<string> GenerateTrendInsights(TrendAnalysisDto trend)
{
    var insights = new List<string>();

    insights.Add($"Overall trend is {trend.TrendDirection.ToLower()} with average growth rate of {trend.AverageGrowthRate:F2}%");

    if (trend.PercentageChange > 0)
    {
        insights.Add($"Total increase of {trend.PercentageChange:F2}% from {trend.StartPeriod} to {trend.EndPeriod}");
    }
    else if (trend.PercentageChange < 0)
    {
        insights.Add($"Total decrease of {Math.Abs(trend.PercentageChange):F2}% from {trend.StartPeriod} to {trend.EndPeriod}");
    }

    if (trend.DataPoints.Any(p => p.PercentageChange.HasValue))
    {
        var volatility = trend.DataPoints
            .Where(p => p.PercentageChange.HasValue)
            .Select(p => Math.Abs(p.PercentageChange.Value))
            .Average();

        if (volatility > 20)
        {
            insights.Add($"High volatility detected with average absolute change of {volatility:F2}%");
        }
    }

    return insights;
}

#endregion

#region Comparison Methods

public async Task<ComparisonResultDto> ComparePeriodsAsync(string period1, string period2)
{
    try
    {
        _logger.LogInformation("Comparing periods: {Period1} vs {Period2}", period1, period2);

        var data1 = await _dataRepo.GetByPeriodAsync(period1);
        var data2 = await _dataRepo.GetByPeriodAsync(period2);

        if (!data1.Any() || !data2.Any())
        {
            throw new InvalidOperationException("Insufficient data for comparison");
        }

        var result = new ComparisonResultDto
        {
            Period1 = period1,
            Period2 = period2,
            ComparisonDate = DateTime.UtcNow
        };

        var categories = data1.Select(d => d.Category)
            .Union(data2.Select(d => d.Category))
            .Distinct();

        foreach (var category in categories)
        {
            var value1 = data1.Where(d => d.Category == category).Sum(d => d.Amount);
            var value2 = data2.Where(d => d.Category == category).Sum(d => d.Amount);

            var variance = value2 - value1;
            var percentageChange = value1 != 0 ? (variance / value1) * 100 : 0;

            var metric = new ComparisonMetric
            {
                Category = category,
                Value1 = value1,
                Value2 = value2,
                Variance = variance,
                PercentageChange = percentageChange,
                ChangeType = variance > 0 ? "Increase" : variance < 0 ? "Decrease" : "NoChange"
            };

            result.Metrics[category] = metric;

            if (Math.Abs(percentageChange) > 10)
            {
                result.SignificantChanges.Add($"{category}: {percentageChange:F2}% change ({metric.ChangeType})");
            }
        }

        var totalChange1 = data1.Sum(d => d.Amount);
        var totalChange2 = data2.Sum(d => d.Amount);

        if (totalChange2 > totalChange1)
            result.OverallTrend = "Growth";
        else if (totalChange2 < totalChange1)
            result.OverallTrend = "Decline";
        else
            result.OverallTrend = "Stable";

        return result;
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Error comparing periods");
        throw;
    }
}

public async Task<ComparisonResultDto> CompareDocumentsAsync(int documentId1, int documentId2)
{
    var doc1 = await _documentRepo.GetWithDataAsync(documentId1);
    var doc2 = await _documentRepo.GetWithDataAsync(documentId2);

    if (doc1 == null || doc2 == null)
    {
        throw new ArgumentException("One or both documents not found");
    }

    var period1 = doc1.FinancialDataRecords.FirstOrDefault()?.Period ?? "Document 1";
    var period2 = doc2.FinancialDataRecords.FirstOrDefault()?.Period ?? "Document 2";

    return await ComparePeriodsAsync(period1, period2);
}

public async Task<Dictionary<string, decimal>> GetVarianceAnalysisAsync(int documentId1, int documentId2)
{
    var comparison = await CompareDocumentsAsync(documentId1, documentId2);

    return comparison.Metrics.ToDictionary(
        m => m.Key,
        m => m.Value.Variance
    );
}

#endregion

// TO BE CONTINUED IN NEXT FILE...
