// PART 2 OF FINANCIALSERVICE - ADDITIONAL METHODS
// This file contains the remaining implementation methods
// Copy these into FinancialService.cs before the closing brace

#region Trend Analysis Methods

public async Task<TrendAnalysisDto> AnalyzeTrendsAsync(List<int> documentIds)
{
    var periods = new List<string>();
    foreach (var docId in documentIds)
    {
        var doc = await _documentRepo.GetWithDataAsync(docId);
        if (doc?.FinancialDataRecords.Any() == true)
        {
            var period = doc.FinancialDataRecords.First().Period;
            if (!periods.Contains(period))
                periods.Add(period);
        }
    }

    return await AnalyzeTrendsByPeriodAsync(periods);
}

public async Task<TrendAnalysisDto> AnalyzeTrendsByPeriodAsync(List<string> periods)
{
    try
    {
        _logger.LogInformation("Analyzing trends for {Count} periods", periods.Count);

        var allData = new List<FinancialData>();
        foreach (var period in periods.OrderBy(p => p))
        {
            var periodData = await _dataRepo.GetByPeriodAsync(period);
            allData.AddRange(periodData);
        }

        if (!allData.Any())
        {
            throw new InvalidOperationException("No data found for specified periods");
        }

        var periodTotals = allData
            .GroupBy(d => d.Period)
            .OrderBy(g => g.Key)
            .Select(g => new TrendDataPoint
            {
                Period = g.Key,
                Value = g.Sum(d => d.Amount)
            })
            .ToList();

        for (int i = 1; i < periodTotals.Count; i++)
        {
            var previous = periodTotals[i - 1].Value;
            var current = periodTotals[i].Value;

            if (previous != 0)
            {
                periodTotals[i].PercentageChange = ((current - previous) / previous) * 100;
            }
        }

        var trendDirection = DetermineTrendDirection(periodTotals);
        var growthRates = periodTotals
            .Where(p => p.PercentageChange.HasValue)
            .Select(p => p.PercentageChange.Value)
            .ToList();

        var avgGrowthRate = growthRates.Any() ? growthRates.Average() : 0;

        var result = new TrendAnalysisDto
        {
            Category = "Overall",
            DataPoints = periodTotals,
            TrendDirection = trendDirection,
            AverageGrowthRate = avgGrowthRate,
            StartPeriod = periods.First(),
            EndPeriod = periods.Last(),
            TotalChange = periodTotals.Last().Value - periodTotals.First().Value,
            PercentageChange = periodTotals.First().Value != 0
                ? ((periodTotals.Last().Value - periodTotals.First().Value) / periodTotals.First().Value) * 100
                : 0
        };

        result.Insights = GenerateTrendInsights(result);

        return result;
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Error analyzing trends");
        throw;
    }
}

public async Task<List<TrendDataPoint>> GetTrendDataAsync(string category, List<string> periods)
{
    var dataPoints = new List<TrendDataPoint>();

    foreach (var period in periods.OrderBy(p => p))
    {
        var periodData = await _dataRepo.GetByPeriodAsync(period);
        var categoryData = periodData.Where(d => d.Category.Equals(category, StringComparison.OrdinalIgnoreCase));

        var total = categoryData.Sum(d => d.Amount);

        dataPoints.Add(new TrendDataPoint
        {
            Period = period,
            Value = total
        });
    }

    for (int i = 1; i < dataPoints.Count; i++)
    {
        var previous = dataPoints[i - 1].Value;
        var current = dataPoints[i].Value;

        if (previous != 0)
        {
            dataPoints[i].PercentageChange = ((current - previous) / previous) * 100;
        }
    }

    return dataPoints;
}

public async Task<decimal> CalculateGrowthRateAsync(string category, string startPeriod, string endPeriod)
{
    var startData = await _dataRepo.GetByPeriodAsync(startPeriod);
    var endData = await _dataRepo.GetByPeriodAsync(endPeriod);

    var startValue = startData
        .Where(d => d.Category.Equals(category, StringComparison.OrdinalIgnoreCase))
        .Sum(d => d.Amount);

    var endValue = endData
        .Where(d => d.Category.Equals(category, StringComparison.OrdinalIgnoreCase))
        .Sum(d => d.Amount);

    if (startValue == 0)
        return 0;

    return ((endValue - startValue) / startValue) * 100;
}

private string DetermineTrendDirection(List<TrendDataPoint> dataPoints)
{
    if (dataPoints.Count < 2)
        return "Insufficient Data";

    var changes = dataPoints
        .Where(p => p.PercentageChange.HasValue)
        .Select(p => p.PercentageChange.Value)
        .ToList();

    if (!changes.Any())
        return "Stable";

    var avgChange = changes.Average();

    if (avgChange > 5)
        return "Increasing";
    else if (avgChange < -5)
        return "Decreasing";
    else
        return "Stable";
}

private List<string> GenerateTrendInsights(TrendAnalysisDto trend)
{
    var insights = new List<string>();

    insights.Add($"Overall trend is {trend.TrendDirection.ToLower()} with average growth rate of {trend.AverageGrowthRate:F2}%");

    if (trend.PercentageChange > 0)
    {
        insights.Add($"Total increase of {trend.PercentageChange:F2}% from {trend.StartPeriod} to {trend.EndPeriod}");
    }
    else if (trend.PercentageChange < 0)
    {
        insights.Add($"Total decrease of {Math.Abs(trend.PercentageChange):F2}% from {trend.StartPeriod} to {trend.EndPeriod}");
    }

    if (trend.DataPoints.Any(p => p.PercentageChange.HasValue))
    {
        var volatility = trend.DataPoints
            .Where(p => p.PercentageChange.HasValue)
            .Select(p => Math.Abs(p.PercentageChange.Value))
            .Average();

        if (volatility > 20)
        {
            insights.Add($"High volatility detected with average absolute change of {volatility:F2}%");
        }
    }

    return insights;
}

#endregion

#region Comparison Methods

public async Task<ComparisonResultDto> ComparePeriodsAsync(string period1, string period2)
{
    try
    {
        _logger.LogInformation("Comparing periods: {Period1} vs {Period2}", period1, period2);

        var data1 = await _dataRepo.GetByPeriodAsync(period1);
        var data2 = await _dataRepo.GetByPeriodAsync(period2);

        if (!data1.Any() || !data2.Any())
        {
            throw new InvalidOperationException("Insufficient data for comparison");
        }

        var result = new ComparisonResultDto
        {
            Period1 = period1,
            Period2 = period2,
            ComparisonDate = DateTime.UtcNow
        };

        var categories = data1.Select(d => d.Category)
            .Union(data2.Select(d => d.Category))
            .Distinct();

        foreach (var category in categories)
        {
            var value1 = data1.Where(d => d.Category == category).Sum(d => d.Amount);
            var value2 = data2.Where(d => d.Category == category).Sum(d => d.Amount);

            var variance = value2 - value1;
            var percentageChange = value1 != 0 ? (variance / value1) * 100 : 0;

            var metric = new ComparisonMetric
            {
                Category = category,
                Value1 = value1,
                Value2 = value2,
                Variance = variance,
                PercentageChange = percentageChange,
                ChangeType = variance > 0 ? "Increase" : variance < 0 ? "Decrease" : "NoChange"
            };

            result.Metrics[category] = metric;

            if (Math.Abs(percentageChange) > 10)
            {
                result.SignificantChanges.Add($"{category}: {percentageChange:F2}% change ({metric.ChangeType})");
            }
        }

        var totalChange1 = data1.Sum(d => d.Amount);
        var totalChange2 = data2.Sum(d => d.Amount);

        if (totalChange2 > totalChange1)
            result.OverallTrend = "Growth";
        else if (totalChange2 < totalChange1)
            result.OverallTrend = "Decline";
        else
            result.OverallTrend = "Stable";

        return result;
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Error comparing periods");
        throw;
    }
}

public async Task<ComparisonResultDto> CompareDocumentsAsync(int documentId1, int documentId2)
{
    var doc1 = await _documentRepo.GetWithDataAsync(documentId1);
    var doc2 = await _documentRepo.GetWithDataAsync(documentId2);

    if (doc1 == null || doc2 == null)
    {
        throw new ArgumentException("One or both documents not found");
    }

    var period1 = doc1.FinancialDataRecords.FirstOrDefault()?.Period ?? "Document 1";
    var period2 = doc2.FinancialDataRecords.FirstOrDefault()?.Period ?? "Document 2";

    return await ComparePeriodsAsync(period1, period2);
}

public async Task<Dictionary<string, decimal>> GetVarianceAnalysisAsync(int documentId1, int documentId2)
{
    var comparison = await CompareDocumentsAsync(documentId1, documentId2);

    return comparison.Metrics.ToDictionary(
        m => m.Key,
        m => m.Value.Variance
    );
}

#endregion

// TO BE CONTINUED IN NEXT FILE...
// PART 3 OF FINANCIALSERVICE - FORECASTING, AI, AND ANOMALY DETECTION
// Copy these into FinancialService.cs after Part 2

#region Forecasting Methods

public async Task<ForecastResultDto> GenerateForecastAsync(string category, int periodsAhead)
{
    try
    {
        _logger.LogInformation("Generating forecast for {Category}, {PeriodsAhead} periods ahead", category, periodsAhead);

        var allData = await _dataRepo.GetAllAsync();
        var categoryData = allData
            .Where(d => d.Category.Equals(category, StringComparison.OrdinalIgnoreCase))
            .GroupBy(d => d.Period)
            .OrderBy(g => g.Key)
            .Select(g => g.Sum(d => d.Amount))
            .ToList();

        if (categoryData.Count < 3)
        {
            throw new InvalidOperationException("Insufficient historical data for forecasting (need at least 3 periods)");
        }

        var forecasted = ForecastLinear(categoryData, periodsAhead);

        var result = new ForecastResultDto
        {
            Category = category,
            Method = "Linear Regression",
            ConfidenceLevel = 70,
            GeneratedDate = DateTime.UtcNow
        };

        var lastPeriod = allData.Max(d => d.Period);
        for (int i = 1; i <= periodsAhead; i++)
        {
            var forecastedValue = forecasted[i - 1];
            var margin = forecastedValue * 0.1m;

            result.ForecastedValues.Add(new ForecastDataPoint
            {
                Period = $"{lastPeriod}+{i}",
                ForecastedValue = forecastedValue,
                LowerBound = forecastedValue - margin,
                UpperBound = forecastedValue + margin
            });
        }

        result.Assumptions.Add("Based on linear trend analysis of historical data");
        result.Assumptions.Add("Assumes consistent market conditions");

        result.RiskFactors.Add("Market volatility could impact actual values");
        result.RiskFactors.Add("External economic factors not considered");

        return result;
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Error generating forecast");
        throw;
    }
}

public async Task<ForecastResultDto> GenerateSimpleForecastAsync(List<decimal> historicalValues, int periodsAhead)
{
    var forecasted = ForecastLinear(historicalValues, periodsAhead);

    var result = new ForecastResultDto
    {
        Category = "General",
        Method = "Simple Linear Forecast",
        ConfidenceLevel = 65,
        GeneratedDate = DateTime.UtcNow
    };

    for (int i = 1; i <= periodsAhead; i++)
    {
        var value = forecasted[i - 1];
        var margin = value * 0.15m;

        result.ForecastedValues.Add(new ForecastDataPoint
        {
            Period = $"Period {i}",
            ForecastedValue = value,
            LowerBound = value - margin,
            UpperBound = value + margin
        });
    }

    return result;
}

public async Task<List<decimal>> CalculateMovingAverageAsync(List<decimal> values, int period)
{
    var movingAverages = new List<decimal>();

    if (values.Count < period)
    {
        return movingAverages;
    }

    for (int i = period - 1; i < values.Count; i++)
    {
        var sum = values.Skip(i - period + 1).Take(period).Sum();
        movingAverages.Add(sum / period);
    }

    return movingAverages;
}

private List<decimal> ForecastLinear(List<decimal> historicalValues, int periodsAhead)
{
    var n = historicalValues.Count;

    var sumX = 0m;
    var sumY = 0m;
    var sumXY = 0m;
    var sumX2 = 0m;

    for (int i = 0; i < n; i++)
    {
        var x = i + 1;
        var y = historicalValues[i];

        sumX += x;
        sumY += y;
        sumXY += x * y;
        sumX2 += x * x;
    }

    var slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
    var intercept = (sumY - slope * sumX) / n;

    var forecasts = new List<decimal>();
    for (int i = 1; i <= periodsAhead; i++)
    {
        var x = n + i;
        var forecast = slope * x + intercept;
        forecasts.Add(Math.Max(0, forecast));
    }

    return forecasts;
}

#endregion

#region AI-Enhanced Analysis Methods

public async Task<AnalysisResponseDto> GenerateAIInsightsAsync(int documentId, AnalysisType analysisType)
{
    try
    {
        _logger.LogInformation("Generating AI insights for document {DocumentId}, type: {AnalysisType}", documentId, analysisType);

        var stopwatch = Stopwatch.StartNew();

        var document = await _documentRepo.GetWithDataAsync(documentId);
        if (document == null)
        {
            throw new ArgumentException($"Document {documentId} not found");
        }

        var data = document.FinancialDataRecords.ToList();

        string aiResponse = analysisType switch
        {
            AnalysisType.Summary => await _aiService.GenerateSummaryAsync(data),
            AnalysisType.TrendAnalysis => await _aiService.AnalyzeTrendsAsync(data, data.FirstOrDefault()?.Period ?? ""),
            AnalysisType.AnomalyDetection => await _aiService.DetectAnomaliesAsync(data),
            _ => await _aiService.GenerateSummaryAsync(data)
        };

        stopwatch.Stop();

        var response = new AnalysisResponseDto
        {
            DocumentId = documentId,
            AnalysisType = analysisType,
            DetailedAnalysis = aiResponse,
            ExecutionTime = (int)stopwatch.ElapsedMilliseconds,
            GeneratedDate = DateTime.UtcNow,
            ModelUsed = "Llama 3.2"
        };

        response.KeyFindings = AIResponseParser.ExtractKeyFindings(aiResponse);
        response.Recommendations = AIResponseParser.ExtractRecommendations(aiResponse);
        response.Summary = aiResponse.Length > 500
            ? aiResponse.Substring(0, 500) + "..."
            : aiResponse;

        // Save analysis to database
        var analysis = new AIAnalysis
        {
            DocumentId = documentId,
            AnalysisType = analysisType.ToString(),
            Prompt = $"Generated {analysisType} analysis",
            Response = aiResponse,
            ModelUsed = "Llama 3.2",
            ExecutionTime = (int)stopwatch.ElapsedMilliseconds,
            CreatedDate = DateTime.UtcNow
        };

        await _analysisRepo.AddAsync(analysis);
        await _analysisRepo.SaveChangesAsync();

        return response;
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Error generating AI insights");
        throw;
    }
}

public async Task<AnalysisResponseDto> GenerateCustomAnalysisAsync(int documentId, string question)
{
    try
    {
        _logger.LogInformation("Generating custom AI analysis for document {DocumentId}", documentId);

        var stopwatch = Stopwatch.StartNew();

        var document = await _documentRepo.GetWithDataAsync(documentId);
        if (document == null)
        {
            throw new ArgumentException($"Document {documentId} not found");
        }

        var data = document.FinancialDataRecords.ToList();

        var aiResponse = await _aiService.CustomAnalysisAsync(question, data);

        stopwatch.Stop();

        var response = new AnalysisResponseDto
        {
            DocumentId = documentId,
            AnalysisType = AnalysisType.Custom,
            DetailedAnalysis = aiResponse,
            Summary = question,
            ExecutionTime = (int)stopwatch.ElapsedMilliseconds,
            GeneratedDate = DateTime.UtcNow,
            ModelUsed = "Llama 3.2"
        };

        response.KeyFindings = AIResponseParser.ExtractKeyFindings(aiResponse);
        response.Recommendations = AIResponseParser.ExtractRecommendations(aiResponse);

        return response;
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Error generating custom AI analysis");
        throw;
    }
}

public async Task<string> GenerateFinancialNarrativeAsync(int documentId)
{
    var summary = await GetFinancialSummaryAsync(documentId);
    var ratios = await CalculateFinancialRatiosAsync(documentId);

    var prompt = $@"Generate a professional financial narrative based on the following data:

Summary:
- Total Revenue: {summary.TotalRevenue:C}
- Total Expenses: {summary.TotalExpenses:C}
- Net Income: {summary.NetIncome:C}
- Total Assets: {summary.TotalAssets:C}
- Total Liabilities: {summary.TotalLiabilities:C}

Key Ratios:
{string.Join("\n", ratios.Select(r => $"- {r.Key}: {r.Value:F2}"))}

Provide a concise 2-3 paragraph narrative explaining the financial position.";

    return await _aiService.GenerateResponseAsync(prompt);
}

#endregion

#region Anomaly Detection Methods

public async Task<List<AnomalyDto>> DetectAnomaliesAsync(int documentId)
{
    try
    {
        _logger.LogInformation("Detecting anomalies in document {DocumentId}", documentId);

        var document = await _documentRepo.GetWithDataAsync(documentId);
        if (document == null)
        {
            throw new ArgumentException($"Document {documentId} not found");
        }

        var data = document.FinancialDataRecords.ToList();

        return await DetectOutliersAsync(data);
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Error detecting anomalies");
        throw;
    }
}

public async Task<List<AnomalyDto>> DetectOutliersAsync(List<FinancialData> data)
{
    var anomalies = new List<AnomalyDto>();

    if (!data.Any())
        return anomalies;

    var categoryGroups = data.GroupBy(d => d.Category);

    foreach (var group in categoryGroups)
    {
        var values = group.Select(d => d.Amount).ToList();

        if (values.Count < 3)
            continue;

        var mean = values.Average();
        var stdDev = CalculateStandardDeviation(values.Select(v => (decimal)v).ToList());

        foreach (var record in group)
        {
            var deviation = Math.Abs((double)record.Amount - (double)mean);
            var deviationInStdDev = stdDev > 0 ? deviation / stdDev : 0;

            if (deviationInStdDev > 3)
            {
                var severity = deviationInStdDev > 5 ? "High" : deviationInStdDev > 4 ? "Medium" : "Low";

                anomalies.Add(new AnomalyDto
                {
                    RecordId = record.Id,
                    AccountName = record.AccountName,
                    Period = record.Period,
                    Value = record.Amount,
                    ExpectedValue = (decimal)mean,
                    Deviation = (decimal)deviation,
                    DeviationPercentage = mean != 0 ? (decimal)(deviation / (double)mean * 100) : 0,
                    Severity = severity,
                    Reason = $"Value is {deviationInStdDev:F2} standard deviations from category mean",
                    DetectedDate = DateTime.UtcNow
                });
            }
        }
    }

    return anomalies;
}

public async Task<bool> IsAnomalousValueAsync(decimal value, string category, string period)
{
    var data = await _dataRepo.GetByCategoryAsync(category);
    var periodData = data.Where(d => d.Period == period).ToList();

    if (!periodData.Any())
        return false;

    var values = periodData.Select(d => d.Amount).ToList();
    var mean = values.Average();
    var stdDev = CalculateStandardDeviation(values);

    var deviation = Math.Abs((double)value - (double)mean);
    var deviationInStdDev = stdDev > 0 ? deviation / stdDev : 0;

    return deviationInStdDev > 3;
}

private double CalculateStandardDeviation(List<decimal> values)
{
    if (!values.Any())
        return 0;

    var avg = values.Average();
    var sumOfSquaresOfDifferences = values
        .Select(val => (double)(val - avg) * (double)(val - avg))
        .Sum();

    return Math.Sqrt(sumOfSquaresOfDifferences / values.Count);
}

#endregion
